OOP:

Por archivo, genero una clase distinta. En lugar de tener un archivo con mil lineas de código, lo organizo en varios archivos más pequeños (no spaghetti)

Objetos manejan comportamiento (métodos, cosas que hacen) y propiedades.

Herencia: comparten atributos y comportamientos. Evito replicar el código. Si necesito que una clase tenga los mismos campos o mismas funciones, las codifico
solo en la clase "padre".

Encapsulamiento: no es propio de C#. Los métodos/características son private/protected/public. TELL DON'T ASK.
		 Las propiedades no son modificables. Cada objeto es autónomo.

GET/SET: {get; set;}. Permite que las clases externas puedan modificar mis propiedades.

Static: método dentro de la clase que no pertenece a ninguna instancia. Métodos que puedo usar de la clase sin necesidad de instanciarlos.

Polimorfirmo: cómo responden dos objetos a un mensaje. Declarar una función que devuelven los mismos valores pero la cantidad de parámetros o los tipos de
parámetros son distintos. Hacen lo mismo, reciben otros datos y devuelven datos distintos.

Abstracción: cuando le pido algo a un objeto sin tener interés en cómo lo hace. concepto black box. forma de interactuar con los objetos, "separarme" del problema
puedo llamar a un método que todavía no está codeado.

Interface: "contrato" - declaración. si implemento una interfaz debo usar todos los métodos y propiedades declarados en ella. No define comportamiento.
NO SE HEREDAN, SE IMPLEMENTAN. No hay nada que heredar, no define comportamiento. No se puede hacer un new. Varias clases pueden implementar una misma interfaz.
Clase abstracta: a diferencia de la interface, define comportamiento. No se puede instanciar, solo se puede heredar. NO se puede hacer un new.

Static: al comenzar la ejecución ya va a estar instanciado y cargado con el valor que definí en un principio. 
Abstracto: 
Virtual: si heredo un comportamiento debería hacer un override. Heredo un método/comportamiento con la posibilidad de modificarlo (o debería).

DLL: archivo binario. Referenciables: permite llamarla desde otro lado. Ejemplo: import en Java
Archivo generado al compilar un proyecto.

Class library: librería dinámica que se monta en memoria una vez que se llama la ejecución.

Nuget: package manager que me permite bajar cosas de internet y poder utilizarlas en nuestro código. AKA Importar librerías.

Estructura de proyecto:

Solución
   |
   |--> Project > genero DLL (assembley) >
   |--> Project > genero DLL		 >

GAC: directorio que maneja todas las assembley. (Global Assembley Cache)

JSON: Java Script Object notation. Representación de objeto. 

PDB: ayuda a debuggear. Me permite poner breakpoints y usar funcionalidades del debugger. Puedo utilizar trace para identificar puntos críticos.

Recursividad: mala práctica, lo opuesto a performante. 

SOLID ---> principios/criterios de diseño empleados como reglas. Buenas prácticas a la hora de diseñar objetos.

S: Single responsability. Responsabilidad. Independencia de otras clases. Si es una clase muy extensa respecto a sus métodos debería considerar particionarla.

---

Comandos Git:

git init			inicio un repositorio (oculto) vacío en el directorio donde estoy parado
touch <name>			genero un file
git status			devuelve los cambios que no actualizaste/guardaste
git add	<nombre>		permite agregar cambios/archivos individuales a tu commit (hito: estado de algo en el tiempo. Deben ser cosas puntuales, pequeñas, seguras y que funcionen, que representen un incremento de valor)
git add .			subo todos los cambios de la carpeta en la que estoy parado. Si tengo otro directorio "anidado" meto todo, incluídas sus subcarpetas, no las anteriores.
git add --all / -A		todos los cambios del repositorio sin importar dónde estoy parado.
git commit -m "mensaje"		"m" mensaje que vamos a dejar en el commit para entender qué hice
git remote add origin <url>	
git pull remote branch		traer los cambios
git push -u origin master	subir los cambios

"Estoy parado en un Working Directory, al hacer un Add paso todo a un "Staging area". Una vez que hago el commit, paso al "Head". Todo lo que está en el head ya está subido."

borrar bin y objects y luego pushear

Estados Git:

Untracked		al ser nuevo, no tiene seguimiento de los archivos
Staged			está creado pero no está agregado, falta commit
Committed		todos mis cambios ya están guardados, commiteados
Modified		hay cambios sin guardar en el archivo

Set mínimo de archivos:

CI = define ciertos pasos de validación previa a subir a git para evitar pisarse y otros posibles inconvenientes.

Trunk Based Dev.com:

estrategias de branching, metodología de trabajo con git (master, development)

generar un branch a partir del master y luego unificarlo con master. Branch más pequeños (2/3 días) y luego lo subo al master.

31/05 - Repaso general

Using: invocar namespace. Es un import.

using ( var A=SW()) {}		disposal. Reservo memoria definida entre los () y al final de la ejecución la libera. No espera al garbage disposal.

try/catch			prueba lo que está en el try, si no anda, devuelve el catch previo.

LINQ:

- Where(predicate)		subset de una lista. Filtra la lista al final con un criterio. Devuelve un nuevo objeto (lista) filtrado.
- Select(x=>x.edad)		devuelve exactamente lo que tengo entre (), con el tipo de dato que tiene el campo (en este caso edad).
- Single			Si la lista es más de un elemento, da error. Lista vacía: devuelve null.
- Fod				First or default. Filtro simil where pero devuelve solo el primero o nulo, por más que haya varios. Lista vacía: devuelve null.
- Any(condición)		Devuelve true o false según encuentre o no alguien que cumpla la condición.
- Union				

GENERICS:

public class List<T> : where T : IDisposable
	T obj = new List?

func:

public List<T> Filter<T>(List<T> lista)

return lista.w().ToList()